#!/usr/bin/env python3
#
# This script uses pydicom to write a JSON file for the DICOM files in the
# directory specified as an argument.
#
# To install required Python packages: `pip3 install -r requirements.txt`.

import base64
import glob
import numpy as np
import os
import pathlib
import pydicom
import simplejson
import sys


def dicom_to_json(file):
    print(file)

    delete_file_if_exists(file + ".json")
    delete_file_if_exists(file + ".pixel_array.json")

    # Read file with pydicom
    data_set = pydicom.dcmread(file, force=True)
    dicom_json_dict = data_set.to_json_dict()

    # Add the transfer syntax UID to the output JSON, pydicom doesn't include it
    # by default
    is_big_endian = False
    if "TransferSyntaxUID" in data_set.file_meta:
        transfer_syntax_uid = data_set.file_meta.TransferSyntaxUID
        dicom_json_dict["00020010"] = {"vr": "UI", "Value": [transfer_syntax_uid]}

        is_big_endian = transfer_syntax_uid == "1.2.840.10008.1.2.2"

    standardize_json_dict(data_set, dicom_json_dict, is_big_endian)

    # Write the result to a JSON file
    pydicom_result = simplejson.dumps(dicom_json_dict, indent=2, sort_keys=True)
    pathlib.Path(file + ".json").write_text(pydicom_result)

    dicom_pixel_data_to_json(file, data_set)


# Writes the pixel data values to a separate JSON file.
def dicom_pixel_data_to_json(file, data_set):
    # Default to the 'Implicit VR Little Endian' transfer syntax
    if not hasattr(data_set.file_meta, "TransferSyntaxUID"):
        data_set.file_meta.TransferSyntaxUID = "1.2.840.10008.1.2.1"

    # pydicom doesn't yet support the JPEG XL transfer syntaxes added in DICOM
    # 2024d, or the 'Deflated Image Frame Compression' transfer syntax added in
    # DICOM 2025a, so skip them
    if (
        data_set.file_meta.TransferSyntaxUID == "1.2.840.10008.1.2.4.110"
        or data_set.file_meta.TransferSyntaxUID == "1.2.840.10008.1.2.4.111"
        or data_set.file_meta.TransferSyntaxUID == "1.2.840.10008.1.2.4.112"
        or data_set.file_meta.TransferSyntaxUID == "1.2.840.10008.1.2.8.1"
    ):
        return

    # pydicom can't decode RLE Lossless data that's a packed 1-bit per pixel
    # bitmap
    if (
        data_set.file_meta.TransferSyntaxUID == "1.2.840.10008.1.2.5"
        and data_set.BitsAllocated == 1
    ):
        return

    # pydicom < 3.1.0 can't decode packed 1-bit per pixel bitmaps that aren't
    # byte aligned
    if (
        not data_set.file_meta.TransferSyntaxUID.is_encapsulated
        and hasattr(data_set, "BitsAllocated")
        and data_set.BitsAllocated == 1
        and ((data_set.Rows * data_set.Columns) % 8 != 0)
    ):
        return

    if (
        not hasattr(data_set, "PixelData")
        or not hasattr(data_set, "SamplesPerPixel")
        or not hasattr(data_set, "PhotometricInterpretation")
        or data_set.PixelData is None
        or (
            data_set.file_meta.TransferSyntaxUID.is_encapsulated
            and data_set.file_meta.TransferSyntaxUID != "1.2.840.10008.1.2.5"
        )
    ):
        return

    frame_data = None

    # Single channel grayscale pixel data is output as JSON so the raw values
    # can be compared
    if data_set.SamplesPerPixel == 1:
        if (
            data_set.PhotometricInterpretation == "MONOCHROME1"
            or data_set.PhotometricInterpretation == "MONOCHROME2"
        ):
            frame_data = data_set.pixel_array.tolist()
            if not isinstance(frame_data[0][0], list):
                frame_data = [frame_data]

        elif data_set.PhotometricInterpretation == "PALETTE COLOR":
            frame_data = pydicom.pixels.apply_color_lut(
                data_set.pixel_array, data_set
            ).astype(np.float64)

            bits_stored = data_set.RedPaletteColorLookupTableDescriptor[2]
            frame_data /= (1 << bits_stored) - 1

            frame_data = frame_data.tolist()
            if not isinstance(frame_data[0][0][0], list):
                frame_data = [frame_data]

    elif data_set.SamplesPerPixel == 3 and (
        data_set.PhotometricInterpretation == "RGB"
        or data_set.PhotometricInterpretation == "YBR_FULL"
        or data_set.PhotometricInterpretation == "YBR_FULL_422"
    ):
        frame_data = data_set.pixel_array.astype(np.float64)
        frame_data /= (1 << data_set.BitsStored) - 1

        frame_data = frame_data.tolist()
        if not isinstance(frame_data[0][0][0], list):
            frame_data = [frame_data]

    if frame_data is not None:
        frame_data = simplejson.dumps(frame_data)
        pathlib.Path(file + ".pixel_array.json").write_text(frame_data)


# Takes a DICOM JSON conversion generated by pydicom and makes some updates to
# it to exactly match DCMfx's output.
def standardize_json_dict(data_set, dicom_json_dict, is_big_endian):
    for tag, value in dicom_json_dict.copy().items():
        vr = value["vr"]

        # Remove retired group length tags, the SpecificCharacterSet tag, and
        # the data set trailing padding tag
        if tag.endswith("0000") or tag == "00080005" or tag == "FFFCFFFC":
            del dicom_json_dict[tag]

        # Replace invalid "OB or OW" VRs with "UN" to conform to the DICOM JSON
        # spec, the former is not permitted
        elif vr == "OB or OW":
            value["vr"] = "UN"

        # Convert simple values
        elif vr != "SQ" and "Value" in value:

            def rstrip_string_value(s):
                if vr == "ST" or vr == "UT":
                    return s.rstrip(" ")

                return s.rstrip()

            # Strip strings
            value["Value"] = [
                (rstrip_string_value(v) if isinstance(v, str) else v)
                for v in value["Value"]
            ]

            # Turn empty strings into 'None'
            value["Value"] = [(None if v == "" else v) for v in value["Value"]]

            # Remove empty Value arrays
            if value["Value"] == []:
                del value["Value"]

        # Byte swap big endian to little endian in inline binaries. This is what
        # dcm2json outputs, and DCMfx does the same thing, i.e. InlineBinary in
        # DICOM JSON data is always little endian.
        elif (
            is_big_endian
            and "InlineBinary" in value
            and vr in ["OW", "OD", "OF", "OL", "OV"]
        ):
            item_size = {"OW": 2, "OD": 8, "OF": 4, "OL": 4, "OV": 8}[vr]

            # Recognize 32/64-bit pixel data that uses the OW VR
            if (
                tag == "7FE00010"
                and vr == "OW"
                and (
                    getattr(data_set, "BitsAllocated") == 32
                    or getattr(data_set, "BitsAllocated") == 64
                )
            ):
                item_size = 4

            bytes = base64.b64decode(value["InlineBinary"])

            # Iterate over the bytearray in chunks of `item_size`
            swapped = bytearray()
            for i in range(0, len(bytes), item_size):
                item = bytes[i : i + item_size]
                swapped.extend(item[::-1])

            value["InlineBinary"] = base64.b64encode(swapped)

        # Recursively sanitize sequences
        elif vr == "SQ" and "Value" in value:
            for item in value["Value"]:
                standardize_json_dict(data_set, item, is_big_endian)


def delete_file_if_exists(file):
    path = pathlib.Path(file)
    if path.exists():
        path.unlink()


if __name__ == "__main__":
    dicom_files = []
    for root, _, files in os.walk(os.path.dirname(os.path.abspath(__file__))):
        for file in files:
            if file.endswith(".dcm"):
                dicom_to_json(os.path.join(root, file))
